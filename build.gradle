plugins {
    id 'java-library'
    id 'eclipse'
    id 'idea'
    id 'maven-publish'
    id 'net.neoforged.gradle.userdev' version '7.0.80'
    id 'com.modrinth.minotaur' version '2.+' // Modrinth publishing plugin
    id 'net.darkhax.curseforgegradle' version '1.1.18' // CurseForge publishing plugin
    id 'se.bjurr.gitchangelog.git-changelog-gradle-plugin'  version '2.1.2' // Changelog generation plugin
}

version = mod_version
group = mod_group_id

repositories {
    mavenLocal()
}

base {
    archivesName = mod_id
}

java.toolchain.languageVersion = JavaLanguageVersion.of(17)

//minecraft.accessTransformers.file rootProject.file('src/main/resources/META-INF/accesstransformer.cfg')
//minecraft.accessTransformers.entry public net.minecraft.client.Minecraft textureManager # textureManager

runs {
    configureEach {
        systemProperty 'forge.logging.markers', 'REGISTRIES'

        systemProperty 'forge.logging.console.level', 'debug'

        modSource project.sourceSets.main
    }

    client {
        // Comma-separated list of namespaces to load gametests from. Empty = all namespaces.
        systemProperty 'forge.enabledGameTestNamespaces', project.mod_id
    }

    server {
        systemProperty 'forge.enabledGameTestNamespaces', project.mod_id
        programArgument '--nogui'
    }

    gameTestServer {
        systemProperty 'forge.enabledGameTestNamespaces', project.mod_id
    }

    data {
        programArguments.addAll '--mod', project.mod_id, '--all', '--output', file('src/generated/resources/').getAbsolutePath(), '--existing', file('src/main/resources/').getAbsolutePath()
    }
}

sourceSets {
    main {
        resources {
            srcDir 'src/generated/resources'
        }
    }
}

dependencies {
    implementation "net.neoforged:neoforge:${neo_version}"
}

tasks.withType(ProcessResources).configureEach {
    var replaceProperties = [
            minecraft_version   : minecraft_version, minecraft_version_range: minecraft_version_range,
            neo_version         : neo_version, neo_version_range: neo_version_range,
            loader_version_range: loader_version_range,
            mod_id              : mod_id, mod_name: mod_name, mod_license: mod_license, mod_version: mod_version,
            mod_authors         : mod_authors, mod_description: mod_description, pack_format_number: pack_format_number,
    ]
    inputs.properties replaceProperties

    filesMatching(['META-INF/mods.toml', 'pack.mcmeta']) {
        expand replaceProperties + [project: project]
    }
}

publishing {
    publications {
        register('mavenJava', MavenPublication) {
            from components.java
        }
    }
    repositories {
        maven {
            url "file://${project.projectDir}/repo"
        }
    }
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8' // Use the UTF-8 charset for Java compilation
}

def modAPIReadable = [
        'neo': "NeoForge",
        'forge': "Forge",
        'fabric': "Fabric",
        'quilt': "Quilt"
]
def modAPILoader = [
        'neo': "neoforge",
        'forge': "forge",
        'fabric': "fabric",
        'quilt': "quilt"
]

def releaseVersionName = "${mod_version} for ${modAPIReadable[mod_api]} ${minecraft_version}"

// Modrinth
modrinth {
    token = System.getenv("BUILD_MODRINTH_TOKEN") // Remember to have the MODRINTH_TOKEN environment variable set or else this will fail - just make sure it stays private!
    projectId = modrinth_projectId // This can be the project ID or the slug. Either will work!
    versionNumber = mod_version // You don't need to set this manually. Will fail if Modrinth has this version already
    versionName = releaseVersionName
    versionType = "release" // This is the default -- can also be `beta` or `alpha`
    uploadFile = jar // With Loom, this MUST be set to `remapJar` instead of `jar`!
    gameVersions = [minecraft_version] // Must be an array, even with only one version
    loaders = [modAPILoader[mod_api]] // Must also be an array - no need to specify this if you're using Loom or ForgeGradle
}

// CurseForge
import net.darkhax.curseforgegradle.TaskPublishCurseForge
import net.darkhax.curseforgegradle.Constants as CFG_Constants

tasks.register('publishCurseForge', TaskPublishCurseForge) {
    // This token is used to authenticate with CurseForge. It should be handled
    // with the same level of care and security as your actual password. You
    // should never share your token with an untrusted source or publish it
    // publicly to GitHub or embed it within a project. The best practice is to
    // store this token in an environment variable or a build secret.
    apiToken = System.getenv("BULLD_CURSEFORGE_API_KEY")

    // Tells CurseForgeGradle to publish the output of the jar task. This will
    // return a UploadArtifact object that can be used to further configure the
    // file.
    def mainFile = upload(curseforge_projectId, jar)
    mainFile.displayName = "CreativeTabSearch-${mod_api}-${minecraft_version}-${mod_version}.jar"
    mainFile.releaseType = CFG_Constants.RELEASE_TYPE_RELEASE
    mainFile.addModLoader(modAPILoader[mod_api])
    mainFile.addGameVersion(minecraft_version)
}

// Git changelog generation
import se.bjurr.gitchangelog.plugin.gradle.GitChangelogTask

def previousVersionCommit = System.getenv("BUILD_PREVIOUS_VERSION_COMMIT")
if (previousVersionCommit == null) {
    previousVersionCommit = "HEAD~5"
    logger.warn("Environment variable BUILD_PREVIOUS_VERSION_COMMIT is missing! Using the default value: ${previousVersionCommit}")
}

tasks.register('genMarkdownChangelog', GitChangelogTask) {
    fromRepo = projectDir.absolutePath.toString()
    file = buildDir.toPath().resolve('changelog.md').toFile()
    untaggedName = releaseVersionName
    fromCommit = previousVersionCommit
    toRef = "HEAD"
    templateContent = projectDir.toPath().resolve('changelog').resolve('changelog-markdown.mustache').toFile().getText()
}
